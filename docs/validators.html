<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>validator.validators API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>validator.validators</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import glob
import math
import os
import re
from abc import ABCMeta, abstractmethod
from enum import Enum

from shapely.geometry import Point, Polygon


class FunType(Enum):
    NAME = 1
    ROW = 2
    FILE = 3
    STORAGE = 4
    MULTIROW = 5


def utm_to_wsg84(
    east_coordinate: float,
    north_coordinate: float,
    zone: int = 19,
    north_hemisphere: bool = False,
) -&gt; tuple:
    &#34;&#34;&#34;
    Convert utm to wsg84 coordinates

    Args:

        east_coordinate: easting
        north_coordinate: northing
        zone:  zone
        north_hemisphere: true | false

    Returns:

        tuple: (lat, long)

    &#34;&#34;&#34;
    if not north_hemisphere:
        north_coordinate = 10000000 - north_coordinate

    a = 6378137
    e = 0.081819191
    e1sq = 0.006739497
    k0 = 0.9996

    arc = north_coordinate / k0
    mu = arc / (
        a
        * (
            1
            - math.pow(e, 2) / 4.0
            - 3 * math.pow(e, 4) / 64.0
            - 5 * math.pow(e, 6) / 256.0
        )
    )

    ei = (1 - math.pow((1 - e * e), (1 / 2.0))) / (1 + math.pow((1 - e * e), (1 / 2.0)))

    ca = 3 * ei / 2 - 27 * math.pow(ei, 3) / 32.0

    cb = 21 * math.pow(ei, 2) / 16 - 55 * math.pow(ei, 4) / 32
    cc = 151 * math.pow(ei, 3) / 96
    cd = 1097 * math.pow(ei, 4) / 512
    phi1 = (
        mu
        + ca * math.sin(2 * mu)
        + cb * math.sin(4 * mu)
        + cc * math.sin(6 * mu)
        + cd * math.sin(8 * mu)
    )

    n0 = a / math.pow((1 - math.pow((e * math.sin(phi1)), 2)), (1 / 2.0))

    r0 = a * (1 - e * e) / math.pow((1 - math.pow((e * math.sin(phi1)), 2)), (3 / 2.0))
    fact1 = n0 * math.tan(phi1) / r0

    _a1 = 500000 - east_coordinate
    dd0 = _a1 / (n0 * k0)
    fact2 = dd0 * dd0 / 2

    t0 = math.pow(math.tan(phi1), 2)
    q0 = e1sq * math.pow(math.cos(phi1), 2)
    fact3 = (5 + 3 * t0 + 10 * q0 - 4 * q0 * q0 - 9 * e1sq) * math.pow(dd0, 4) / 24

    fact4 = (
        (61 + 90 * t0 + 298 * q0 + 45 * t0 * t0 - 252 * e1sq - 3 * q0 * q0)
        * math.pow(dd0, 6)
        / 720
    )

    lof1 = _a1 / (n0 * k0)
    lof2 = (1 + 2 * t0 + q0) * math.pow(dd0, 3) / 6.0
    lof3 = (
        (5 - 2 * q0 + 28 * t0 - 3 * math.pow(q0, 2) + 8 * e1sq + 24 * math.pow(t0, 2))
        * math.pow(dd0, 5)
        / 120
    )
    _a2 = (lof1 - lof2 + lof3) / math.cos(phi1)
    _a3 = _a2 * 180 / math.pi

    latitude = 180 * (phi1 - fact1 * (fact2 + fact3 + fact4)) / math.pi

    if not north_hemisphere:
        latitude = -latitude

    longitude = ((zone &gt; 0) and (6 * zone - 183.0) or 3.0) - _a3
    return latitude, longitude


class Validator(object, metaclass=ABCMeta):
    def __init__(self, args):
        &#34;&#34;&#34;
        Init method, it storage args and initialite a row counter

        Args:

            args: validator args

        &#34;&#34;&#34;
        self.args = args
        self.row_counter = 0
        super().__init__()

    @abstractmethod
    def apply(self, args=None):
        &#34;&#34;&#34;
        Apply the validator method

        Args:
            args: validator args
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_error(self):
        &#34;&#34;&#34;
        Method that return a error dict

        The error dict has 4 parameters:

        name: error name
        type: error type
        message: error message
        row: row number
        cols: column number

        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_fun_type(self):
        &#34;&#34;&#34;
        Return the fun type

        The funtype is
        &#34;&#34;&#34;
        pass


class RootValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Return always true
        &#34;&#34;&#34;
        return True

    def get_error(self) -&gt; dict:
        &#34;&#34;&#34;
        Return error dict with info about the validation.

        Returns:
            dict: A dict with all the parameteres

        &#34;&#34;&#34;
        return {
            &#34;name&#34;: &#34;Raiz incorrecta&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La raíz del directorio debe tener un nombre vacío en la configuración.&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME


class NameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if file exists in path

        Validator args:

            path: name path to search
            name: filename
        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        name = self.args[&#34;name&#34;]
        real_path = os.path.join(path, name)
        return os.path.exists(real_path)

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Nombre incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El nombre del directorio o archivo &#39;{0}&#39; no se encuentra en el directorio &#39;{1}&#39;.&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME


class RegexNameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if regex file exist in path

        Validator args:

            path: path name to search
            name: filename in unix regex format
        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        regex = self.args[&#34;name&#34;]
        name = glob.glob(os.path.join(path, regex))
        if name:
            name = os.path.split(name[0])[1]
        validator = args
        validator.temp_name = name
        return True if len(name) &gt; 0 else False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No existe archivo con expresión regular&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;No existe directorio o archivo con la expresión regular &#39;{0}&#39; en el directorio &#39;{1}&#39; .&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self):
        return FunType.NAME


class RegexMultiNameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if regex file list exist in path

        Validator args:

            path: path name to search
            name: filename list with unix regex format

        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        regex_list = self.args[&#34;name&#34;]
        name_list = [glob.glob(os.path.join(path, regex)) for regex in regex_list]
        if name_list[0]:
            name_list = [os.path.split(name[0])[1] for name in name_list]
        validator = args
        validator.temp_name = name_list
        return True if len(name_list) &gt; 0 else False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No existen archivos con expresiones regulares&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;No existen directorios o archivos con la expresión regular &#39;{0}&#39; en el directorio &#39;{1}&#39; .&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME


class MinRowsValidator(Validator):
    counter = 0
    status = False

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Apply row counter and check if it has the minimal rows

        Validator args:

            min: min rows

        &#34;&#34;&#34;
        self.counter += 1
        min_rows = self.args[&#34;min&#34;]
        res = self.counter &gt;= min_rows
        if res:
            self.status = True
        return res

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Número de filas menor al correcto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El archivo posee {0} filas, cuando debería tener {1} filas como mínimo.&#34;.format(
                self.counter, self.args[&#34;min&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.FILE


class ASCIIColValidator(Validator):
    def __init__(self, args):

        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is in ASCII

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value.isascii():
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        var = [self.args[&#34;row&#34;][index] for index in self.cols_error]
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;La variable&#34;
        mid = &#34;posee ñ o acentos en la fila&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Las variables&#34;
            mid = &#34;poseen ñ o acentos en la fila&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores contienen ñ o acentos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} &#39;{1}&#39; {2} {3} {4} {5}.&#34;.format(
                head, var, mid, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class DuplicateValueValidator(Validator):
    def __init__(self, args):

        self.values = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col has not duplicated value

        Validator args:
            col_index: column index to check

        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        col_to_check = self.args[&#34;col_index&#34;]
        value = self.args[&#34;row&#34;][col_to_check]
        if value in self.values:
            return False
        else:
            self.values.append(value)
        return True

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;Valor duplicado&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; está duplicada en la fila {1}, columna {2}.&#34;.format(
                var, self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class NotEmptyRowValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if is not empty row
        &#34;&#34;&#34;
        self.row_counter += 1
        if not args:
            return False
        else:
            return True

    def get_error(self):
        return {
            &#34;name&#34;: &#34;Fila vacía&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El archivo posee una linea vacía en la fila {0}.&#34;.format(
                self.row_counter
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class HeaderValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check header

        Validator args:

            header: header to check
        &#34;&#34;&#34;
        if len(args) == len(self.args[&#34;header&#34;]):
            for header, expected_header in zip(args, self.args[&#34;header&#34;]):
                if header != expected_header:
                    return False
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Header incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El header no corresponde al archivo. Este debe ser: {0}&#34;.format(
                self.args[&#34;header&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class NotEmptyValueValidator(Validator):
    def __init__(self, args):

        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col has not empty value

        Validator args:

            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value:
                self.cols_error.append(col)
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor vacío&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores vacíos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valor vacío&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class StringDomainValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if columns are in domain list

        Validator args:

            domain: string list
            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        domain = self.args[&#34;domain&#34;]
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if value not in domain:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor incorrecto&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores incorrectos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores incorrectos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}. Los valores solo pueden ser &#39;{4}&#39;&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names), self.args[&#34;domain&#34;]
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class RegexValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check col value with regex

        Validator args:

            col_index: column index to check
            regex: unix regex
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        col_to_check = self.args[&#34;col_index&#34;]
        value = self.args[&#34;row&#34;][col_to_check]
        regex = self.args[&#34;regex&#34;]
        return True if re.search(regex, value) else False

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no cumple con la expresión regular&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no cumple con el formato {1} en la fila {2}, columna {3}.&#34;.format(
                var, self.args[&#34;regex_name&#34;], self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class NumericRangeValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is in numeric range

        Validator args:

            lower_bound: min value
            upper_bound: max value
            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        lower_bound = int(self.args[&#34;lower_bound&#34;])
        upper_bound = int(self.args[&#34;upper_bound&#34;])
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = int(self.args[&#34;row&#34;][col])
            if value &lt; lower_bound or value &gt; upper_bound:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Valor fuera de rango&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Valores fuera de rango&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores fuera de rango&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} {1} en la fila {2}, {3} {4}. Los valores solo pueden ser parte del rango {5}&#34;.format(
                head,
                self.cols_error,
                self.row_counter,
                tail,
                &#34;, &#34;.join(cols_names),
                [self.args[&#34;lower_bound&#34;], self.args[&#34;upper_bound&#34;]],
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class TimeValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is time value (HH:MM:SS)

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        time_format = &#34;%H:%M:%S&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            try:
                datetime.datetime.strptime(value, time_format)
            except ValueError:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en formato de hora incorrecto&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores en formato de hora incorrecto&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Formato de hora incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class FloatValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is float value

        Validator args:

            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value.replace(&#34;.&#34;, &#34;&#34;, 1).isdigit():
                self.cols_error.append(col)
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en formato distinto a float&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores en formato distinto a float&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Formato float incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class GreaterThanValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if upper_col is greater than lower_col

        Validator args:

            upper_col: max value
            lower_col: min value
            type: comparison type (time)
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        upper_col = args[self.args[&#34;upper_col&#34;]]
        lower_col = args[self.args[&#34;lower_col&#34;]]
        comparison_type = self.args[&#34;type&#34;]
        if comparison_type == &#34;time&#34;:
            time_format = &#34;%H:%M:%S&#34;
            try:
                upper_time = datetime.datetime.strptime(upper_col, time_format)
                lower_time = datetime.datetime.strptime(lower_col, time_format)
            except ValueError:
                return False
            return upper_time &gt; lower_time
        else:
            return upper_col &gt; lower_col

    def get_error(self) -&gt; dict:
        first_value_header = self.args[&#34;header&#34;][self.args[&#34;upper_col&#34;]]
        last_value_header = self.args[&#34;header&#34;][self.args[&#34;lower_col&#34;]]

        return {
            &#34;name&#34;: &#34;Inconsistencia entre valores&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;En la fila {1} el valor de la columna {0} es menor al valor de la columna {2}.&#34;.format(
                first_value_header, self.row_counter, last_value_header
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: [first_value_header, last_value_header],
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class StoreColValue(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Save col index in named storage

        Validator args:

            col_index: column index to check
            storage_name: name to save values
        &#34;&#34;&#34;
        index = self.args[&#34;col_index&#34;]
        var = args[index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage_name = self.args[&#34;storage_name&#34;]
        if data_validator.storage.get(storage_name, 0) == 0:
            data_validator.storage[storage_name] = [var]
        else:
            data_validator.storage[storage_name].append(var)
        return True

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No se puede almacenar valor&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;Error al almacenar valor&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE


class CheckColStorageValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value is in given storage

        Validator args:

            col_index: column index to check
            storage_name: storage name to check data
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        index = self.args[&#34;col_index&#34;]
        val = args[index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        return val in storage

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no se encuentra en los valores válidos para &#39;{1}&#39; en la fila {2}, columna {3}.&#34;.format(
                var, self.args[&#34;storage_name&#34;], self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE


class BoundingBoxValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if coordinate values are in given bounding box

        Validator args:
            x_coordinate_index: column index of x coordinate
            y_coordinate_index: column index of y coordinate
            coordinate_system: coordinate system (utm, wgs84)
            bounding_box: coordinates list that represent a bounding box
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        x_coordinate_index = self.args[&#34;x_coordinate_index&#34;]
        y_coordinate_index = self.args[&#34;y_coordinate_index&#34;]
        x = float(args[x_coordinate_index])
        y = float(args[y_coordinate_index])
        if self.args[&#34;coordinate_system&#34;] == &#34;utm&#34;:
            x, y = utm_to_wsg84(x, y, 19)
            point = Point(x, y)
            bounding_box = Polygon(self.args[&#34;bounding_box&#34;])
        return bounding_box.contains(point)

    def get_error(self) -&gt; dict:
        x_coordinate_index = self.args[&#34;x_coordinate_index&#34;]
        y_coordinate_index = self.args[&#34;y_coordinate_index&#34;]
        x = float(self.args[&#34;row&#34;][x_coordinate_index])
        y = float(self.args[&#34;row&#34;][y_coordinate_index])
        return {
            &#34;name&#34;: &#34;Coordenadas inválidas&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;Las coordenadas &#39;{0}&#39;, &#39;{1}&#39; en la fila {2} no se encuentran en el rango geográfico correcto.&#34;.format(
                x, y, self.row_counter
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: [
                self.args[&#34;header&#34;][x_coordinate_index],
                self.args[&#34;header&#34;][y_coordinate_index],
            ],
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW


class StoreColDictValues(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Save cols index in args

        Validator args:

            storage_name: storage name to save data
            key_index: key index to save data
            value_indexes: column index list to check

        &#34;&#34;&#34;
        key_index = self.args[&#34;key_index&#34;]
        value_indexes = self.args[&#34;value_indexes&#34;]
        key_value = args[key_index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage_name = self.args[&#34;storage_name&#34;]
        if data_validator.storage.get(storage_name, 0) == 0:
            value_dict = {key_value: []}
        else:
            if data_validator.storage[storage_name].get(key_value, 0) == 0:
                value_dict = data_validator.storage[storage_name]
                value_dict[key_value] = []
            else:
                value_dict = data_validator.storage[storage_name]
        var = []
        for value in value_indexes:
            var.append(args[value])
        value_dict[key_value].append(var)
        data_validator.storage[storage_name] = value_dict
        return True

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No se puede almacenar valor&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;Error al almacenar valor&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE


class CheckStoreColDictValuesValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value dict is in given storage

        Validator args:

            storage_name: storage name to check
            key_name: key name to check in storage
            value_indexes: column index list to check
            transform_data: transform data value if needed (wsg84_to_utm)
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        key_name = self.args[&#34;key_name&#34;]
        value_indexes = self.args[&#34;value_indexes&#34;]
        values = [float(args[value]) for value in value_indexes]
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        storage_key = storage.get(key_name, []) if storage != [] else []
        transform_data = self.args[&#34;transform_data&#34;]
        res = False
        if transform_data == &#34;wsg84_to_utm&#34;:
            for storage_values in storage_key:
                storage_values = utm_to_wsg84(
                    float(storage_values[0]), float(storage_values[1])
                )
                if math.isclose(
                    storage_values[0], values[0], abs_tol=0.1
                ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                    res = True
                    break
        elif transform_data == &#34;wsg84_to_utm_as_bounding_box&#34;:
            point = Point(*values)
            bounding_box = []
            for storage_values in storage_key:
                storage_values = utm_to_wsg84(
                    float(storage_values[0]), float(storage_values[1])
                )
                bounding_box.append(storage_values)
            bounding_box = Polygon(bounding_box)
            res = bounding_box.contains(point)
        else:
            for storage_values in storage_key:
                storage_values = [float(storage_values[0]), float(storage_values[1])]
                if math.isclose(
                    storage_values[0], values[0], abs_tol=0.1
                ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                    res = True
                    break
        return res

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.args[&#34;value_indexes&#34;]]
        var = [self.args[&#34;row&#34;][value] for value in self.args[&#34;value_indexes&#34;]]
        head = &#34;no se encuentra&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;no se encuentran&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;&#39;{0}&#39; {1} en los valores válidos para {2} en la fila {3}, {4} {5}.&#34;.format(
                var, head, self.args[&#34;key_name&#34;], self.row_counter, tail, cols_names
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE


class CheckColStorageMultiValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value is in given storage when col value is a list

        Validator args:

            col_index: col index to check
            storage_name: storage name to check data
            separator: separator of stored data
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        index = self.args[&#34;col_index&#34;]
        separator = self.args[&#34;separator&#34;]
        values = args[index].split(separator)
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        status = True
        self.args[&#34;error_values&#34;] = []
        for val in values:
            if val not in storage:
                self.args[&#34;error_values&#34;].append(val)
                status = False

        return status

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no se encuentra en los valores válidos para {1} en la fila {2}, columna {3}.&#34;.format(
                self.args[&#34;error_values&#34;],
                self.args[&#34;storage_name&#34;],
                self.row_counter,
                col_name,
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE


class MultiRowColValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        self.row_number_error = [0]
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if multiples rows have the same cols value

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        # multiple rows
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        base_row = self.args[&#34;row&#34;][0]
        row_number = 0
        for row in self.args[&#34;row&#34;]:
            for col in cols_to_check:
                if not row[col] == base_row[col]:
                    self.cols_error.append(col)
                    self.row_number_error.append(row_number)
            row_number += 1
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        file_names = self.args[&#34;file_names&#34;]
        error_file_names = [file_names[index] for index in self.row_number_error]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en distinto en los archivos&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores distintos en los archivos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores distintos en archivos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} {4} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names), error_file_names
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.MULTIROW


check_name_functions = {
    &#34;name&#34;: NameValidator,
    &#34;regex&#34;: RegexNameValidator,
    &#34;root&#34;: RootValidator,
    &#34;multi-regex&#34;: RegexMultiNameValidator,
}

file_functions = {
    &#34;min_rows&#34;: MinRowsValidator,
    &#34;ascii&#34;: ASCIIColValidator,
    &#34;duplicate&#34;: DuplicateValueValidator,
    &#34;not_empty_row&#34;: NotEmptyRowValidator,
    &#34;string_domain&#34;: StringDomainValueValidator,
    &#34;regex_value&#34;: RegexValueValidator,
    &#34;numeric_range&#34;: NumericRangeValueValidator,
    &#34;greater_than&#34;: GreaterThanValueValidator,
    &#34;float&#34;: FloatValueValidator,
    &#34;time&#34;: TimeValueValidator,
    &#34;not_empty_col&#34;: NotEmptyValueValidator,
    &#34;store_col_value&#34;: StoreColValue,
    &#34;check_col_storage_value&#34;: CheckColStorageValueValidator,
    &#34;bounding_box&#34;: BoundingBoxValueValidator,
    &#34;store_col_dict_values&#34;: StoreColDictValues,
    &#34;check_store_col_dict_values&#34;: CheckStoreColDictValuesValidator,
    &#34;check_col_storage_multi_value&#34;: CheckColStorageMultiValueValidator,
    &#34;multi_row_col_value&#34;: MultiRowColValueValidator,
}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="validator.validators.utm_to_wsg84"><code class="name flex">
<span>def <span class="ident">utm_to_wsg84</span></span>(<span>east_coordinate: float, north_coordinate: float, zone: int = 19, north_hemisphere: bool = False) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Convert utm to wsg84 coordinates</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>east_coordinate</code></strong></dt>
<dd>easting</dd>
<dt><strong><code>north_coordinate</code></strong></dt>
<dd>northing</dd>
<dt><strong><code>zone</code></strong></dt>
<dd>zone</dd>
<dt><strong><code>north_hemisphere</code></strong></dt>
<dd>true | false</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(lat, long)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def utm_to_wsg84(
    east_coordinate: float,
    north_coordinate: float,
    zone: int = 19,
    north_hemisphere: bool = False,
) -&gt; tuple:
    &#34;&#34;&#34;
    Convert utm to wsg84 coordinates

    Args:

        east_coordinate: easting
        north_coordinate: northing
        zone:  zone
        north_hemisphere: true | false

    Returns:

        tuple: (lat, long)

    &#34;&#34;&#34;
    if not north_hemisphere:
        north_coordinate = 10000000 - north_coordinate

    a = 6378137
    e = 0.081819191
    e1sq = 0.006739497
    k0 = 0.9996

    arc = north_coordinate / k0
    mu = arc / (
        a
        * (
            1
            - math.pow(e, 2) / 4.0
            - 3 * math.pow(e, 4) / 64.0
            - 5 * math.pow(e, 6) / 256.0
        )
    )

    ei = (1 - math.pow((1 - e * e), (1 / 2.0))) / (1 + math.pow((1 - e * e), (1 / 2.0)))

    ca = 3 * ei / 2 - 27 * math.pow(ei, 3) / 32.0

    cb = 21 * math.pow(ei, 2) / 16 - 55 * math.pow(ei, 4) / 32
    cc = 151 * math.pow(ei, 3) / 96
    cd = 1097 * math.pow(ei, 4) / 512
    phi1 = (
        mu
        + ca * math.sin(2 * mu)
        + cb * math.sin(4 * mu)
        + cc * math.sin(6 * mu)
        + cd * math.sin(8 * mu)
    )

    n0 = a / math.pow((1 - math.pow((e * math.sin(phi1)), 2)), (1 / 2.0))

    r0 = a * (1 - e * e) / math.pow((1 - math.pow((e * math.sin(phi1)), 2)), (3 / 2.0))
    fact1 = n0 * math.tan(phi1) / r0

    _a1 = 500000 - east_coordinate
    dd0 = _a1 / (n0 * k0)
    fact2 = dd0 * dd0 / 2

    t0 = math.pow(math.tan(phi1), 2)
    q0 = e1sq * math.pow(math.cos(phi1), 2)
    fact3 = (5 + 3 * t0 + 10 * q0 - 4 * q0 * q0 - 9 * e1sq) * math.pow(dd0, 4) / 24

    fact4 = (
        (61 + 90 * t0 + 298 * q0 + 45 * t0 * t0 - 252 * e1sq - 3 * q0 * q0)
        * math.pow(dd0, 6)
        / 720
    )

    lof1 = _a1 / (n0 * k0)
    lof2 = (1 + 2 * t0 + q0) * math.pow(dd0, 3) / 6.0
    lof3 = (
        (5 - 2 * q0 + 28 * t0 - 3 * math.pow(q0, 2) + 8 * e1sq + 24 * math.pow(t0, 2))
        * math.pow(dd0, 5)
        / 120
    )
    _a2 = (lof1 - lof2 + lof3) / math.cos(phi1)
    _a3 = _a2 * 180 / math.pi

    latitude = 180 * (phi1 - fact1 * (fact2 + fact3 + fact4)) / math.pi

    if not north_hemisphere:
        latitude = -latitude

    longitude = ((zone &gt; 0) and (6 * zone - 183.0) or 3.0) - _a3
    return latitude, longitude</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="validator.validators.ASCIIColValidator"><code class="flex name class">
<span>class <span class="ident">ASCIIColValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ASCIIColValidator(Validator):
    def __init__(self, args):

        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is in ASCII

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value.isascii():
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        var = [self.args[&#34;row&#34;][index] for index in self.cols_error]
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;La variable&#34;
        mid = &#34;posee ñ o acentos en la fila&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Las variables&#34;
            mid = &#34;poseen ñ o acentos en la fila&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores contienen ñ o acentos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} &#39;{1}&#39; {2} {3} {4} {5}.&#34;.format(
                head, var, mid, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.ASCIIColValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col is in ASCII</p>
<p>Validator args:</p>
<pre><code>col_indexes: column index list to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col is in ASCII

    Validator args:

        col_indexes: column index list to check
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = self.args[&#34;row&#34;][col]
        if not value.isascii():
            self.cols_error.append(col)

    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.BoundingBoxValueValidator"><code class="flex name class">
<span>class <span class="ident">BoundingBoxValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundingBoxValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if coordinate values are in given bounding box

        Validator args:
            x_coordinate_index: column index of x coordinate
            y_coordinate_index: column index of y coordinate
            coordinate_system: coordinate system (utm, wgs84)
            bounding_box: coordinates list that represent a bounding box
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        x_coordinate_index = self.args[&#34;x_coordinate_index&#34;]
        y_coordinate_index = self.args[&#34;y_coordinate_index&#34;]
        x = float(args[x_coordinate_index])
        y = float(args[y_coordinate_index])
        if self.args[&#34;coordinate_system&#34;] == &#34;utm&#34;:
            x, y = utm_to_wsg84(x, y, 19)
            point = Point(x, y)
            bounding_box = Polygon(self.args[&#34;bounding_box&#34;])
        return bounding_box.contains(point)

    def get_error(self) -&gt; dict:
        x_coordinate_index = self.args[&#34;x_coordinate_index&#34;]
        y_coordinate_index = self.args[&#34;y_coordinate_index&#34;]
        x = float(self.args[&#34;row&#34;][x_coordinate_index])
        y = float(self.args[&#34;row&#34;][y_coordinate_index])
        return {
            &#34;name&#34;: &#34;Coordenadas inválidas&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;Las coordenadas &#39;{0}&#39;, &#39;{1}&#39; en la fila {2} no se encuentran en el rango geográfico correcto.&#34;.format(
                x, y, self.row_counter
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: [
                self.args[&#34;header&#34;][x_coordinate_index],
                self.args[&#34;header&#34;][y_coordinate_index],
            ],
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.BoundingBoxValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if coordinate values are in given bounding box</p>
<p>Validator args:
x_coordinate_index: column index of x coordinate
y_coordinate_index: column index of y coordinate
coordinate_system: coordinate system (utm, wgs84)
bounding_box: coordinates list that represent a bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if coordinate values are in given bounding box

    Validator args:
        x_coordinate_index: column index of x coordinate
        y_coordinate_index: column index of y coordinate
        coordinate_system: coordinate system (utm, wgs84)
        bounding_box: coordinates list that represent a bounding box
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    x_coordinate_index = self.args[&#34;x_coordinate_index&#34;]
    y_coordinate_index = self.args[&#34;y_coordinate_index&#34;]
    x = float(args[x_coordinate_index])
    y = float(args[y_coordinate_index])
    if self.args[&#34;coordinate_system&#34;] == &#34;utm&#34;:
        x, y = utm_to_wsg84(x, y, 19)
        point = Point(x, y)
        bounding_box = Polygon(self.args[&#34;bounding_box&#34;])
    return bounding_box.contains(point)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.CheckColStorageMultiValueValidator"><code class="flex name class">
<span>class <span class="ident">CheckColStorageMultiValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckColStorageMultiValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value is in given storage when col value is a list

        Validator args:

            col_index: col index to check
            storage_name: storage name to check data
            separator: separator of stored data
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        index = self.args[&#34;col_index&#34;]
        separator = self.args[&#34;separator&#34;]
        values = args[index].split(separator)
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        status = True
        self.args[&#34;error_values&#34;] = []
        for val in values:
            if val not in storage:
                self.args[&#34;error_values&#34;].append(val)
                status = False

        return status

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no se encuentra en los valores válidos para {1} en la fila {2}, columna {3}.&#34;.format(
                self.args[&#34;error_values&#34;],
                self.args[&#34;storage_name&#34;],
                self.row_counter,
                col_name,
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.CheckColStorageMultiValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col value is in given storage when col value is a list</p>
<p>Validator args:</p>
<pre><code>col_index: col index to check
storage_name: storage name to check data
separator: separator of stored data
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col value is in given storage when col value is a list

    Validator args:

        col_index: col index to check
        storage_name: storage name to check data
        separator: separator of stored data
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    index = self.args[&#34;col_index&#34;]
    separator = self.args[&#34;separator&#34;]
    values = args[index].split(separator)
    data_validator = self.args[&#34;data_validator&#34;]
    storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
    status = True
    self.args[&#34;error_values&#34;] = []
    for val in values:
        if val not in storage:
            self.args[&#34;error_values&#34;].append(val)
            status = False

    return status</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.CheckColStorageValueValidator"><code class="flex name class">
<span>class <span class="ident">CheckColStorageValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckColStorageValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value is in given storage

        Validator args:

            col_index: column index to check
            storage_name: storage name to check data
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        index = self.args[&#34;col_index&#34;]
        val = args[index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        return val in storage

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no se encuentra en los valores válidos para &#39;{1}&#39; en la fila {2}, columna {3}.&#34;.format(
                var, self.args[&#34;storage_name&#34;], self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.CheckColStorageValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col value is in given storage</p>
<p>Validator args:</p>
<pre><code>col_index: column index to check
storage_name: storage name to check data
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col value is in given storage

    Validator args:

        col_index: column index to check
        storage_name: storage name to check data
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    index = self.args[&#34;col_index&#34;]
    val = args[index]
    data_validator = self.args[&#34;data_validator&#34;]
    storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
    return val in storage</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.CheckStoreColDictValuesValidator"><code class="flex name class">
<span>class <span class="ident">CheckStoreColDictValuesValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckStoreColDictValuesValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col value dict is in given storage

        Validator args:

            storage_name: storage name to check
            key_name: key name to check in storage
            value_indexes: column index list to check
            transform_data: transform data value if needed (wsg84_to_utm)
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        key_name = self.args[&#34;key_name&#34;]
        value_indexes = self.args[&#34;value_indexes&#34;]
        values = [float(args[value]) for value in value_indexes]
        data_validator = self.args[&#34;data_validator&#34;]
        storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
        storage_key = storage.get(key_name, []) if storage != [] else []
        transform_data = self.args[&#34;transform_data&#34;]
        res = False
        if transform_data == &#34;wsg84_to_utm&#34;:
            for storage_values in storage_key:
                storage_values = utm_to_wsg84(
                    float(storage_values[0]), float(storage_values[1])
                )
                if math.isclose(
                    storage_values[0], values[0], abs_tol=0.1
                ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                    res = True
                    break
        elif transform_data == &#34;wsg84_to_utm_as_bounding_box&#34;:
            point = Point(*values)
            bounding_box = []
            for storage_values in storage_key:
                storage_values = utm_to_wsg84(
                    float(storage_values[0]), float(storage_values[1])
                )
                bounding_box.append(storage_values)
            bounding_box = Polygon(bounding_box)
            res = bounding_box.contains(point)
        else:
            for storage_values in storage_key:
                storage_values = [float(storage_values[0]), float(storage_values[1])]
                if math.isclose(
                    storage_values[0], values[0], abs_tol=0.1
                ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                    res = True
                    break
        return res

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.args[&#34;value_indexes&#34;]]
        var = [self.args[&#34;row&#34;][value] for value in self.args[&#34;value_indexes&#34;]]
        head = &#34;no se encuentra&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;no se encuentran&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;El valor no es válido&#34;,
            &#34;type&#34;: &#34;valor&#34;,
            &#34;message&#34;: &#34;&#39;{0}&#39; {1} en los valores válidos para {2} en la fila {3}, {4} {5}.&#34;.format(
                var, head, self.args[&#34;key_name&#34;], self.row_counter, tail, cols_names
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.CheckStoreColDictValuesValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col value dict is in given storage</p>
<p>Validator args:</p>
<pre><code>storage_name: storage name to check
key_name: key name to check in storage
value_indexes: column index list to check
transform_data: transform data value if needed (wsg84_to_utm)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col value dict is in given storage

    Validator args:

        storage_name: storage name to check
        key_name: key name to check in storage
        value_indexes: column index list to check
        transform_data: transform data value if needed (wsg84_to_utm)
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    key_name = self.args[&#34;key_name&#34;]
    value_indexes = self.args[&#34;value_indexes&#34;]
    values = [float(args[value]) for value in value_indexes]
    data_validator = self.args[&#34;data_validator&#34;]
    storage = data_validator.storage.get(self.args[&#34;storage_name&#34;], [])
    storage_key = storage.get(key_name, []) if storage != [] else []
    transform_data = self.args[&#34;transform_data&#34;]
    res = False
    if transform_data == &#34;wsg84_to_utm&#34;:
        for storage_values in storage_key:
            storage_values = utm_to_wsg84(
                float(storage_values[0]), float(storage_values[1])
            )
            if math.isclose(
                storage_values[0], values[0], abs_tol=0.1
            ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                res = True
                break
    elif transform_data == &#34;wsg84_to_utm_as_bounding_box&#34;:
        point = Point(*values)
        bounding_box = []
        for storage_values in storage_key:
            storage_values = utm_to_wsg84(
                float(storage_values[0]), float(storage_values[1])
            )
            bounding_box.append(storage_values)
        bounding_box = Polygon(bounding_box)
        res = bounding_box.contains(point)
    else:
        for storage_values in storage_key:
            storage_values = [float(storage_values[0]), float(storage_values[1])]
            if math.isclose(
                storage_values[0], values[0], abs_tol=0.1
            ) and math.isclose(storage_values[1], values[1], abs_tol=0.1):
                res = True
                break
    return res</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.DuplicateValueValidator"><code class="flex name class">
<span>class <span class="ident">DuplicateValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DuplicateValueValidator(Validator):
    def __init__(self, args):

        self.values = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col has not duplicated value

        Validator args:
            col_index: column index to check

        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        col_to_check = self.args[&#34;col_index&#34;]
        value = self.args[&#34;row&#34;][col_to_check]
        if value in self.values:
            return False
        else:
            self.values.append(value)
        return True

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;Valor duplicado&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; está duplicada en la fila {1}, columna {2}.&#34;.format(
                var, self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.DuplicateValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col has not duplicated value</p>
<p>Validator args:
col_index: column index to check</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col has not duplicated value

    Validator args:
        col_index: column index to check

    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    col_to_check = self.args[&#34;col_index&#34;]
    value = self.args[&#34;row&#34;][col_to_check]
    if value in self.values:
        return False
    else:
        self.values.append(value)
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.FloatValueValidator"><code class="flex name class">
<span>class <span class="ident">FloatValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FloatValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is float value

        Validator args:

            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value.replace(&#34;.&#34;, &#34;&#34;, 1).isdigit():
                self.cols_error.append(col)
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en formato distinto a float&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores en formato distinto a float&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Formato float incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.FloatValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col is float value</p>
<p>Validator args:</p>
<pre><code>col_indexes: column index list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col is float value

    Validator args:

        col_indexes: column index list
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = self.args[&#34;row&#34;][col]
        if not value.replace(&#34;.&#34;, &#34;&#34;, 1).isdigit():
            self.cols_error.append(col)
    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.FunType"><code class="flex name class">
<span>class <span class="ident">FunType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FunType(Enum):
    NAME = 1
    ROW = 2
    FILE = 3
    STORAGE = 4
    MULTIROW = 5</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="validator.validators.FunType.FILE"><code class="name">var <span class="ident">FILE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="validator.validators.FunType.MULTIROW"><code class="name">var <span class="ident">MULTIROW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="validator.validators.FunType.NAME"><code class="name">var <span class="ident">NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="validator.validators.FunType.ROW"><code class="name">var <span class="ident">ROW</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="validator.validators.FunType.STORAGE"><code class="name">var <span class="ident">STORAGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="validator.validators.GreaterThanValueValidator"><code class="flex name class">
<span>class <span class="ident">GreaterThanValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GreaterThanValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if upper_col is greater than lower_col

        Validator args:

            upper_col: max value
            lower_col: min value
            type: comparison type (time)
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        upper_col = args[self.args[&#34;upper_col&#34;]]
        lower_col = args[self.args[&#34;lower_col&#34;]]
        comparison_type = self.args[&#34;type&#34;]
        if comparison_type == &#34;time&#34;:
            time_format = &#34;%H:%M:%S&#34;
            try:
                upper_time = datetime.datetime.strptime(upper_col, time_format)
                lower_time = datetime.datetime.strptime(lower_col, time_format)
            except ValueError:
                return False
            return upper_time &gt; lower_time
        else:
            return upper_col &gt; lower_col

    def get_error(self) -&gt; dict:
        first_value_header = self.args[&#34;header&#34;][self.args[&#34;upper_col&#34;]]
        last_value_header = self.args[&#34;header&#34;][self.args[&#34;lower_col&#34;]]

        return {
            &#34;name&#34;: &#34;Inconsistencia entre valores&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;En la fila {1} el valor de la columna {0} es menor al valor de la columna {2}.&#34;.format(
                first_value_header, self.row_counter, last_value_header
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: [first_value_header, last_value_header],
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.GreaterThanValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if upper_col is greater than lower_col</p>
<p>Validator args:</p>
<pre><code>upper_col: max value
lower_col: min value
type: comparison type (time)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if upper_col is greater than lower_col

    Validator args:

        upper_col: max value
        lower_col: min value
        type: comparison type (time)
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    upper_col = args[self.args[&#34;upper_col&#34;]]
    lower_col = args[self.args[&#34;lower_col&#34;]]
    comparison_type = self.args[&#34;type&#34;]
    if comparison_type == &#34;time&#34;:
        time_format = &#34;%H:%M:%S&#34;
        try:
            upper_time = datetime.datetime.strptime(upper_col, time_format)
            lower_time = datetime.datetime.strptime(lower_col, time_format)
        except ValueError:
            return False
        return upper_time &gt; lower_time
    else:
        return upper_col &gt; lower_col</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.HeaderValidator"><code class="flex name class">
<span>class <span class="ident">HeaderValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeaderValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check header

        Validator args:

            header: header to check
        &#34;&#34;&#34;
        if len(args) == len(self.args[&#34;header&#34;]):
            for header, expected_header in zip(args, self.args[&#34;header&#34;]):
                if header != expected_header:
                    return False
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Header incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El header no corresponde al archivo. Este debe ser: {0}&#34;.format(
                self.args[&#34;header&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.HeaderValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check header</p>
<p>Validator args:</p>
<pre><code>header: header to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check header

    Validator args:

        header: header to check
    &#34;&#34;&#34;
    if len(args) == len(self.args[&#34;header&#34;]):
        for header, expected_header in zip(args, self.args[&#34;header&#34;]):
            if header != expected_header:
                return False
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.MinRowsValidator"><code class="flex name class">
<span>class <span class="ident">MinRowsValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MinRowsValidator(Validator):
    counter = 0
    status = False

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Apply row counter and check if it has the minimal rows

        Validator args:

            min: min rows

        &#34;&#34;&#34;
        self.counter += 1
        min_rows = self.args[&#34;min&#34;]
        res = self.counter &gt;= min_rows
        if res:
            self.status = True
        return res

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Número de filas menor al correcto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El archivo posee {0} filas, cuando debería tener {1} filas como mínimo.&#34;.format(
                self.counter, self.args[&#34;min&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.FILE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="validator.validators.MinRowsValidator.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="validator.validators.MinRowsValidator.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.MinRowsValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Apply row counter and check if it has the minimal rows</p>
<p>Validator args:</p>
<pre><code>min: min rows
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Apply row counter and check if it has the minimal rows

    Validator args:

        min: min rows

    &#34;&#34;&#34;
    self.counter += 1
    min_rows = self.args[&#34;min&#34;]
    res = self.counter &gt;= min_rows
    if res:
        self.status = True
    return res</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.MultiRowColValueValidator"><code class="flex name class">
<span>class <span class="ident">MultiRowColValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiRowColValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        self.row_number_error = [0]
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if multiples rows have the same cols value

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        # multiple rows
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        base_row = self.args[&#34;row&#34;][0]
        row_number = 0
        for row in self.args[&#34;row&#34;]:
            for col in cols_to_check:
                if not row[col] == base_row[col]:
                    self.cols_error.append(col)
                    self.row_number_error.append(row_number)
            row_number += 1
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        file_names = self.args[&#34;file_names&#34;]
        error_file_names = [file_names[index] for index in self.row_number_error]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en distinto en los archivos&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores distintos en los archivos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores distintos en archivos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} {4} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names), error_file_names
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.MULTIROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.MultiRowColValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if multiples rows have the same cols value</p>
<p>Validator args:</p>
<pre><code>col_indexes: column index list to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if multiples rows have the same cols value

    Validator args:

        col_indexes: column index list to check
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    # multiple rows
    self.args[&#34;row&#34;] = args
    cols_to_check = self.args[&#34;col_indexes&#34;]
    base_row = self.args[&#34;row&#34;][0]
    row_number = 0
    for row in self.args[&#34;row&#34;]:
        for col in cols_to_check:
            if not row[col] == base_row[col]:
                self.cols_error.append(col)
                self.row_number_error.append(row_number)
        row_number += 1
    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.NameValidator"><code class="flex name class">
<span>class <span class="ident">NameValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if file exists in path

        Validator args:

            path: name path to search
            name: filename
        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        name = self.args[&#34;name&#34;]
        real_path = os.path.join(path, name)
        return os.path.exists(real_path)

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;Nombre incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El nombre del directorio o archivo &#39;{0}&#39; no se encuentra en el directorio &#39;{1}&#39;.&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.NameValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if file exists in path</p>
<p>Validator args:</p>
<pre><code>path: name path to search
name: filename
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if file exists in path

    Validator args:

        path: name path to search
        name: filename
    &#34;&#34;&#34;
    path = self.args[&#34;path&#34;]
    name = self.args[&#34;name&#34;]
    real_path = os.path.join(path, name)
    return os.path.exists(real_path)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.NotEmptyRowValidator"><code class="flex name class">
<span>class <span class="ident">NotEmptyRowValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotEmptyRowValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if is not empty row
        &#34;&#34;&#34;
        self.row_counter += 1
        if not args:
            return False
        else:
            return True

    def get_error(self):
        return {
            &#34;name&#34;: &#34;Fila vacía&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;El archivo posee una linea vacía en la fila {0}.&#34;.format(
                self.row_counter
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.NotEmptyRowValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if is not empty row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if is not empty row
    &#34;&#34;&#34;
    self.row_counter += 1
    if not args:
        return False
    else:
        return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.NotEmptyValueValidator"><code class="flex name class">
<span>class <span class="ident">NotEmptyValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NotEmptyValueValidator(Validator):
    def __init__(self, args):

        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col has not empty value

        Validator args:

            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if not value:
                self.cols_error.append(col)
        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor vacío&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores vacíos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valor vacío&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.NotEmptyValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col has not empty value</p>
<p>Validator args:</p>
<pre><code>col_indexes: column index list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col has not empty value

    Validator args:

        col_indexes: column index list
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = self.args[&#34;row&#34;][col]
        if not value:
            self.cols_error.append(col)
    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.NumericRangeValueValidator"><code class="flex name class">
<span>class <span class="ident">NumericRangeValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NumericRangeValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is in numeric range

        Validator args:

            lower_bound: min value
            upper_bound: max value
            col_indexes: column index list to check
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        lower_bound = int(self.args[&#34;lower_bound&#34;])
        upper_bound = int(self.args[&#34;upper_bound&#34;])
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = int(self.args[&#34;row&#34;][col])
            if value &lt; lower_bound or value &gt; upper_bound:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Valor fuera de rango&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Valores fuera de rango&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores fuera de rango&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} {1} en la fila {2}, {3} {4}. Los valores solo pueden ser parte del rango {5}&#34;.format(
                head,
                self.cols_error,
                self.row_counter,
                tail,
                &#34;, &#34;.join(cols_names),
                [self.args[&#34;lower_bound&#34;], self.args[&#34;upper_bound&#34;]],
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.NumericRangeValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col is in numeric range</p>
<p>Validator args:</p>
<pre><code>lower_bound: min value
upper_bound: max value
col_indexes: column index list to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col is in numeric range

    Validator args:

        lower_bound: min value
        upper_bound: max value
        col_indexes: column index list to check
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    lower_bound = int(self.args[&#34;lower_bound&#34;])
    upper_bound = int(self.args[&#34;upper_bound&#34;])
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = int(self.args[&#34;row&#34;][col])
        if value &lt; lower_bound or value &gt; upper_bound:
            self.cols_error.append(col)

    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.RegexMultiNameValidator"><code class="flex name class">
<span>class <span class="ident">RegexMultiNameValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexMultiNameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if regex file list exist in path

        Validator args:

            path: path name to search
            name: filename list with unix regex format

        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        regex_list = self.args[&#34;name&#34;]
        name_list = [glob.glob(os.path.join(path, regex)) for regex in regex_list]
        if name_list[0]:
            name_list = [os.path.split(name[0])[1] for name in name_list]
        validator = args
        validator.temp_name = name_list
        return True if len(name_list) &gt; 0 else False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No existen archivos con expresiones regulares&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;No existen directorios o archivos con la expresión regular &#39;{0}&#39; en el directorio &#39;{1}&#39; .&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.RegexMultiNameValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if regex file list exist in path</p>
<p>Validator args:</p>
<pre><code>path: path name to search
name: filename list with unix regex format
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if regex file list exist in path

    Validator args:

        path: path name to search
        name: filename list with unix regex format

    &#34;&#34;&#34;
    path = self.args[&#34;path&#34;]
    regex_list = self.args[&#34;name&#34;]
    name_list = [glob.glob(os.path.join(path, regex)) for regex in regex_list]
    if name_list[0]:
        name_list = [os.path.split(name[0])[1] for name in name_list]
    validator = args
    validator.temp_name = name_list
    return True if len(name_list) &gt; 0 else False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.RegexNameValidator"><code class="flex name class">
<span>class <span class="ident">RegexNameValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexNameValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if regex file exist in path

        Validator args:

            path: path name to search
            name: filename in unix regex format
        &#34;&#34;&#34;
        path = self.args[&#34;path&#34;]
        regex = self.args[&#34;name&#34;]
        name = glob.glob(os.path.join(path, regex))
        if name:
            name = os.path.split(name[0])[1]
        validator = args
        validator.temp_name = name
        return True if len(name) &gt; 0 else False

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No existe archivo con expresión regular&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;No existe directorio o archivo con la expresión regular &#39;{0}&#39; en el directorio &#39;{1}&#39; .&#34;.format(
                self.args[&#34;name&#34;], self.args[&#34;path&#34;]
            ),
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self):
        return FunType.NAME</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.RegexNameValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if regex file exist in path</p>
<p>Validator args:</p>
<pre><code>path: path name to search
name: filename in unix regex format
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if regex file exist in path

    Validator args:

        path: path name to search
        name: filename in unix regex format
    &#34;&#34;&#34;
    path = self.args[&#34;path&#34;]
    regex = self.args[&#34;name&#34;]
    name = glob.glob(os.path.join(path, regex))
    if name:
        name = os.path.split(name[0])[1]
    validator = args
    validator.temp_name = name
    return True if len(name) &gt; 0 else False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.RegexValueValidator"><code class="flex name class">
<span>class <span class="ident">RegexValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegexValueValidator(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check col value with regex

        Validator args:

            col_index: column index to check
            regex: unix regex
        &#34;&#34;&#34;
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        col_to_check = self.args[&#34;col_index&#34;]
        value = self.args[&#34;row&#34;][col_to_check]
        regex = self.args[&#34;regex&#34;]
        return True if re.search(regex, value) else False

    def get_error(self) -&gt; dict:
        index = self.args[&#34;col_index&#34;]
        var = self.args[&#34;row&#34;][index]
        header = self.args[&#34;header&#34;]
        col_name = header[index]

        return {
            &#34;name&#34;: &#34;El valor no cumple con la expresión regular&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La variable &#39;{0}&#39; no cumple con el formato {1} en la fila {2}, columna {3}.&#34;.format(
                var, self.args[&#34;regex_name&#34;], self.row_counter, col_name
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: col_name,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.RegexValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check col value with regex</p>
<p>Validator args:</p>
<pre><code>col_index: column index to check
regex: unix regex
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check col value with regex

    Validator args:

        col_index: column index to check
        regex: unix regex
    &#34;&#34;&#34;
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    col_to_check = self.args[&#34;col_index&#34;]
    value = self.args[&#34;row&#34;][col_to_check]
    regex = self.args[&#34;regex&#34;]
    return True if re.search(regex, value) else False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.RootValidator"><code class="flex name class">
<span>class <span class="ident">RootValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootValidator(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Return always true
        &#34;&#34;&#34;
        return True

    def get_error(self) -&gt; dict:
        &#34;&#34;&#34;
        Return error dict with info about the validation.

        Returns:
            dict: A dict with all the parameteres

        &#34;&#34;&#34;
        return {
            &#34;name&#34;: &#34;Raiz incorrecta&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;La raíz del directorio debe tener un nombre vacío en la configuración.&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.NAME</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.RootValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return always true</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Return always true
    &#34;&#34;&#34;
    return True</code></pre>
</details>
</dd>
<dt id="validator.validators.RootValidator.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Return error dict with info about the validation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dict with all the parameteres</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_error(self) -&gt; dict:
    &#34;&#34;&#34;
    Return error dict with info about the validation.

    Returns:
        dict: A dict with all the parameteres

    &#34;&#34;&#34;
    return {
        &#34;name&#34;: &#34;Raiz incorrecta&#34;,
        &#34;type&#34;: &#34;formato&#34;,
        &#34;message&#34;: &#34;La raíz del directorio debe tener un nombre vacío en la configuración.&#34;,
        &#34;row&#34;: &#34;&#34;,
        &#34;cols&#34;: &#34;&#34;,
    }</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.StoreColDictValues"><code class="flex name class">
<span>class <span class="ident">StoreColDictValues</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoreColDictValues(Validator):
    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Save cols index in args

        Validator args:

            storage_name: storage name to save data
            key_index: key index to save data
            value_indexes: column index list to check

        &#34;&#34;&#34;
        key_index = self.args[&#34;key_index&#34;]
        value_indexes = self.args[&#34;value_indexes&#34;]
        key_value = args[key_index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage_name = self.args[&#34;storage_name&#34;]
        if data_validator.storage.get(storage_name, 0) == 0:
            value_dict = {key_value: []}
        else:
            if data_validator.storage[storage_name].get(key_value, 0) == 0:
                value_dict = data_validator.storage[storage_name]
                value_dict[key_value] = []
            else:
                value_dict = data_validator.storage[storage_name]
        var = []
        for value in value_indexes:
            var.append(args[value])
        value_dict[key_value].append(var)
        data_validator.storage[storage_name] = value_dict
        return True

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No se puede almacenar valor&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;Error al almacenar valor&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.StoreColDictValues.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Save cols index in args</p>
<p>Validator args:</p>
<pre><code>storage_name: storage name to save data
key_index: key index to save data
value_indexes: column index list to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Save cols index in args

    Validator args:

        storage_name: storage name to save data
        key_index: key index to save data
        value_indexes: column index list to check

    &#34;&#34;&#34;
    key_index = self.args[&#34;key_index&#34;]
    value_indexes = self.args[&#34;value_indexes&#34;]
    key_value = args[key_index]
    data_validator = self.args[&#34;data_validator&#34;]
    storage_name = self.args[&#34;storage_name&#34;]
    if data_validator.storage.get(storage_name, 0) == 0:
        value_dict = {key_value: []}
    else:
        if data_validator.storage[storage_name].get(key_value, 0) == 0:
            value_dict = data_validator.storage[storage_name]
            value_dict[key_value] = []
        else:
            value_dict = data_validator.storage[storage_name]
    var = []
    for value in value_indexes:
        var.append(args[value])
    value_dict[key_value].append(var)
    data_validator.storage[storage_name] = value_dict
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.StoreColValue"><code class="flex name class">
<span>class <span class="ident">StoreColValue</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StoreColValue(Validator):
    def __init__(self, args):
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Save col index in named storage

        Validator args:

            col_index: column index to check
            storage_name: name to save values
        &#34;&#34;&#34;
        index = self.args[&#34;col_index&#34;]
        var = args[index]
        data_validator = self.args[&#34;data_validator&#34;]
        storage_name = self.args[&#34;storage_name&#34;]
        if data_validator.storage.get(storage_name, 0) == 0:
            data_validator.storage[storage_name] = [var]
        else:
            data_validator.storage[storage_name].append(var)
        return True

    def get_error(self) -&gt; dict:
        return {
            &#34;name&#34;: &#34;No se puede almacenar valor&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;Error al almacenar valor&#34;,
            &#34;row&#34;: &#34;&#34;,
            &#34;cols&#34;: &#34;&#34;,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.STORAGE</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.StoreColValue.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Save col index in named storage</p>
<p>Validator args:</p>
<pre><code>col_index: column index to check
storage_name: name to save values
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Save col index in named storage

    Validator args:

        col_index: column index to check
        storage_name: name to save values
    &#34;&#34;&#34;
    index = self.args[&#34;col_index&#34;]
    var = args[index]
    data_validator = self.args[&#34;data_validator&#34;]
    storage_name = self.args[&#34;storage_name&#34;]
    if data_validator.storage.get(storage_name, 0) == 0:
        data_validator.storage[storage_name] = [var]
    else:
        data_validator.storage[storage_name].append(var)
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.StringDomainValueValidator"><code class="flex name class">
<span>class <span class="ident">StringDomainValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringDomainValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if columns are in domain list

        Validator args:

            domain: string list
            col_indexes: column index list
        &#34;&#34;&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        domain = self.args[&#34;domain&#34;]
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            if value not in domain:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor incorrecto&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores incorrectos&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Valores incorrectos&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}. Los valores solo pueden ser &#39;{4}&#39;&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names), self.args[&#34;domain&#34;]
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.StringDomainValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if columns are in domain list</p>
<p>Validator args:</p>
<pre><code>domain: string list
col_indexes: column index list
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if columns are in domain list

    Validator args:

        domain: string list
        col_indexes: column index list
    &#34;&#34;&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    domain = self.args[&#34;domain&#34;]
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = self.args[&#34;row&#34;][col]
        if value not in domain:
            self.cols_error.append(col)

    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.TimeValueValidator"><code class="flex name class">
<span>class <span class="ident">TimeValueValidator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeValueValidator(Validator):
    def __init__(self, args):
        self.cols_error = []
        super().__init__(args)

    def apply(self, args=None) -&gt; bool:
        &#34;&#34;&#34;
        Check if col is time value (HH:MM:SS)

        Validator args:

            col_indexes: column index list to check
        &#34;&#34;&#34;
        time_format = &#34;%H:%M:%S&#34;
        self.cols_error = []
        self.row_counter += 1
        self.args[&#34;row&#34;] = args
        cols_to_check = self.args[&#34;col_indexes&#34;]
        for col in cols_to_check:
            value = self.args[&#34;row&#34;][col]
            try:
                datetime.datetime.strptime(value, time_format)
            except ValueError:
                self.cols_error.append(col)

        if len(self.cols_error) == 0:
            return True
        else:
            return False

    def get_error(self) -&gt; dict:
        header = self.args[&#34;header&#34;]
        cols_names = [header[index] for index in self.cols_error]
        head = &#34;Existe un valor en formato de hora incorrecto&#34;
        tail = &#34;columna&#34;
        if len(cols_names) &gt; 1:
            head = &#34;Existen valores en formato de hora incorrecto&#34;
            tail = &#34;columnas&#34;

        return {
            &#34;name&#34;: &#34;Formato de hora incorrecto&#34;,
            &#34;type&#34;: &#34;formato&#34;,
            &#34;message&#34;: &#34;{0} en la fila {1}, {2} {3}.&#34;.format(
                head, self.row_counter, tail, &#34;, &#34;.join(cols_names)
            ),
            &#34;row&#34;: self.row_counter,
            &#34;cols&#34;: cols_names,
        }

    def get_fun_type(self) -&gt; FunType:
        return FunType.ROW</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.TimeValueValidator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if col is time value (HH:MM:SS)</p>
<p>Validator args:</p>
<pre><code>col_indexes: column index list to check
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, args=None) -&gt; bool:
    &#34;&#34;&#34;
    Check if col is time value (HH:MM:SS)

    Validator args:

        col_indexes: column index list to check
    &#34;&#34;&#34;
    time_format = &#34;%H:%M:%S&#34;
    self.cols_error = []
    self.row_counter += 1
    self.args[&#34;row&#34;] = args
    cols_to_check = self.args[&#34;col_indexes&#34;]
    for col in cols_to_check:
        value = self.args[&#34;row&#34;][col]
        try:
            datetime.datetime.strptime(value, time_format)
        except ValueError:
            self.cols_error.append(col)

    if len(self.cols_error) == 0:
        return True
    else:
        return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></b></code>:
<ul class="hlist">
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="validator.validators.Validator"><code class="flex name class">
<span>class <span class="ident">Validator</span></span>
<span>(</span><span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Init method, it storage args and initialite a row counter</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Validator(object, metaclass=ABCMeta):
    def __init__(self, args):
        &#34;&#34;&#34;
        Init method, it storage args and initialite a row counter

        Args:

            args: validator args

        &#34;&#34;&#34;
        self.args = args
        self.row_counter = 0
        super().__init__()

    @abstractmethod
    def apply(self, args=None):
        &#34;&#34;&#34;
        Apply the validator method

        Args:
            args: validator args
        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_error(self):
        &#34;&#34;&#34;
        Method that return a error dict

        The error dict has 4 parameters:

        name: error name
        type: error type
        message: error message
        row: row number
        cols: column number

        &#34;&#34;&#34;
        pass

    @abstractmethod
    def get_fun_type(self):
        &#34;&#34;&#34;
        Return the fun type

        The funtype is
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="validator.validators.ASCIIColValidator" href="#validator.validators.ASCIIColValidator">ASCIIColValidator</a></li>
<li><a title="validator.validators.BoundingBoxValueValidator" href="#validator.validators.BoundingBoxValueValidator">BoundingBoxValueValidator</a></li>
<li><a title="validator.validators.CheckColStorageMultiValueValidator" href="#validator.validators.CheckColStorageMultiValueValidator">CheckColStorageMultiValueValidator</a></li>
<li><a title="validator.validators.CheckColStorageValueValidator" href="#validator.validators.CheckColStorageValueValidator">CheckColStorageValueValidator</a></li>
<li><a title="validator.validators.CheckStoreColDictValuesValidator" href="#validator.validators.CheckStoreColDictValuesValidator">CheckStoreColDictValuesValidator</a></li>
<li><a title="validator.validators.DuplicateValueValidator" href="#validator.validators.DuplicateValueValidator">DuplicateValueValidator</a></li>
<li><a title="validator.validators.FloatValueValidator" href="#validator.validators.FloatValueValidator">FloatValueValidator</a></li>
<li><a title="validator.validators.GreaterThanValueValidator" href="#validator.validators.GreaterThanValueValidator">GreaterThanValueValidator</a></li>
<li><a title="validator.validators.HeaderValidator" href="#validator.validators.HeaderValidator">HeaderValidator</a></li>
<li><a title="validator.validators.MinRowsValidator" href="#validator.validators.MinRowsValidator">MinRowsValidator</a></li>
<li><a title="validator.validators.MultiRowColValueValidator" href="#validator.validators.MultiRowColValueValidator">MultiRowColValueValidator</a></li>
<li><a title="validator.validators.NameValidator" href="#validator.validators.NameValidator">NameValidator</a></li>
<li><a title="validator.validators.NotEmptyRowValidator" href="#validator.validators.NotEmptyRowValidator">NotEmptyRowValidator</a></li>
<li><a title="validator.validators.NotEmptyValueValidator" href="#validator.validators.NotEmptyValueValidator">NotEmptyValueValidator</a></li>
<li><a title="validator.validators.NumericRangeValueValidator" href="#validator.validators.NumericRangeValueValidator">NumericRangeValueValidator</a></li>
<li><a title="validator.validators.RegexMultiNameValidator" href="#validator.validators.RegexMultiNameValidator">RegexMultiNameValidator</a></li>
<li><a title="validator.validators.RegexNameValidator" href="#validator.validators.RegexNameValidator">RegexNameValidator</a></li>
<li><a title="validator.validators.RegexValueValidator" href="#validator.validators.RegexValueValidator">RegexValueValidator</a></li>
<li><a title="validator.validators.RootValidator" href="#validator.validators.RootValidator">RootValidator</a></li>
<li><a title="validator.validators.StoreColDictValues" href="#validator.validators.StoreColDictValues">StoreColDictValues</a></li>
<li><a title="validator.validators.StoreColValue" href="#validator.validators.StoreColValue">StoreColValue</a></li>
<li><a title="validator.validators.StringDomainValueValidator" href="#validator.validators.StringDomainValueValidator">StringDomainValueValidator</a></li>
<li><a title="validator.validators.TimeValueValidator" href="#validator.validators.TimeValueValidator">TimeValueValidator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="validator.validators.Validator.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the validator method</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>validator args</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def apply(self, args=None):
    &#34;&#34;&#34;
    Apply the validator method

    Args:
        args: validator args
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="validator.validators.Validator.get_error"><code class="name flex">
<span>def <span class="ident">get_error</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method that return a error dict</p>
<p>The error dict has 4 parameters:</p>
<p>name: error name
type: error type
message: error message
row: row number
cols: column number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_error(self):
    &#34;&#34;&#34;
    Method that return a error dict

    The error dict has 4 parameters:

    name: error name
    type: error type
    message: error message
    row: row number
    cols: column number

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="validator.validators.Validator.get_fun_type"><code class="name flex">
<span>def <span class="ident">get_fun_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fun type</p>
<p>The funtype is</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_fun_type(self):
    &#34;&#34;&#34;
    Return the fun type

    The funtype is
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="validator" href="index.html">validator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="validator.validators.utm_to_wsg84" href="#validator.validators.utm_to_wsg84">utm_to_wsg84</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="validator.validators.ASCIIColValidator" href="#validator.validators.ASCIIColValidator">ASCIIColValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.ASCIIColValidator.apply" href="#validator.validators.ASCIIColValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.BoundingBoxValueValidator" href="#validator.validators.BoundingBoxValueValidator">BoundingBoxValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.BoundingBoxValueValidator.apply" href="#validator.validators.BoundingBoxValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.CheckColStorageMultiValueValidator" href="#validator.validators.CheckColStorageMultiValueValidator">CheckColStorageMultiValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.CheckColStorageMultiValueValidator.apply" href="#validator.validators.CheckColStorageMultiValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.CheckColStorageValueValidator" href="#validator.validators.CheckColStorageValueValidator">CheckColStorageValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.CheckColStorageValueValidator.apply" href="#validator.validators.CheckColStorageValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.CheckStoreColDictValuesValidator" href="#validator.validators.CheckStoreColDictValuesValidator">CheckStoreColDictValuesValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.CheckStoreColDictValuesValidator.apply" href="#validator.validators.CheckStoreColDictValuesValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.DuplicateValueValidator" href="#validator.validators.DuplicateValueValidator">DuplicateValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.DuplicateValueValidator.apply" href="#validator.validators.DuplicateValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.FloatValueValidator" href="#validator.validators.FloatValueValidator">FloatValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.FloatValueValidator.apply" href="#validator.validators.FloatValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.FunType" href="#validator.validators.FunType">FunType</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.FunType.FILE" href="#validator.validators.FunType.FILE">FILE</a></code></li>
<li><code><a title="validator.validators.FunType.MULTIROW" href="#validator.validators.FunType.MULTIROW">MULTIROW</a></code></li>
<li><code><a title="validator.validators.FunType.NAME" href="#validator.validators.FunType.NAME">NAME</a></code></li>
<li><code><a title="validator.validators.FunType.ROW" href="#validator.validators.FunType.ROW">ROW</a></code></li>
<li><code><a title="validator.validators.FunType.STORAGE" href="#validator.validators.FunType.STORAGE">STORAGE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.GreaterThanValueValidator" href="#validator.validators.GreaterThanValueValidator">GreaterThanValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.GreaterThanValueValidator.apply" href="#validator.validators.GreaterThanValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.HeaderValidator" href="#validator.validators.HeaderValidator">HeaderValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.HeaderValidator.apply" href="#validator.validators.HeaderValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.MinRowsValidator" href="#validator.validators.MinRowsValidator">MinRowsValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.MinRowsValidator.apply" href="#validator.validators.MinRowsValidator.apply">apply</a></code></li>
<li><code><a title="validator.validators.MinRowsValidator.counter" href="#validator.validators.MinRowsValidator.counter">counter</a></code></li>
<li><code><a title="validator.validators.MinRowsValidator.status" href="#validator.validators.MinRowsValidator.status">status</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.MultiRowColValueValidator" href="#validator.validators.MultiRowColValueValidator">MultiRowColValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.MultiRowColValueValidator.apply" href="#validator.validators.MultiRowColValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.NameValidator" href="#validator.validators.NameValidator">NameValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.NameValidator.apply" href="#validator.validators.NameValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.NotEmptyRowValidator" href="#validator.validators.NotEmptyRowValidator">NotEmptyRowValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.NotEmptyRowValidator.apply" href="#validator.validators.NotEmptyRowValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.NotEmptyValueValidator" href="#validator.validators.NotEmptyValueValidator">NotEmptyValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.NotEmptyValueValidator.apply" href="#validator.validators.NotEmptyValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.NumericRangeValueValidator" href="#validator.validators.NumericRangeValueValidator">NumericRangeValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.NumericRangeValueValidator.apply" href="#validator.validators.NumericRangeValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.RegexMultiNameValidator" href="#validator.validators.RegexMultiNameValidator">RegexMultiNameValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.RegexMultiNameValidator.apply" href="#validator.validators.RegexMultiNameValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.RegexNameValidator" href="#validator.validators.RegexNameValidator">RegexNameValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.RegexNameValidator.apply" href="#validator.validators.RegexNameValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.RegexValueValidator" href="#validator.validators.RegexValueValidator">RegexValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.RegexValueValidator.apply" href="#validator.validators.RegexValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.RootValidator" href="#validator.validators.RootValidator">RootValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.RootValidator.apply" href="#validator.validators.RootValidator.apply">apply</a></code></li>
<li><code><a title="validator.validators.RootValidator.get_error" href="#validator.validators.RootValidator.get_error">get_error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.StoreColDictValues" href="#validator.validators.StoreColDictValues">StoreColDictValues</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.StoreColDictValues.apply" href="#validator.validators.StoreColDictValues.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.StoreColValue" href="#validator.validators.StoreColValue">StoreColValue</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.StoreColValue.apply" href="#validator.validators.StoreColValue.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.StringDomainValueValidator" href="#validator.validators.StringDomainValueValidator">StringDomainValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.StringDomainValueValidator.apply" href="#validator.validators.StringDomainValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.TimeValueValidator" href="#validator.validators.TimeValueValidator">TimeValueValidator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.TimeValueValidator.apply" href="#validator.validators.TimeValueValidator.apply">apply</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="validator.validators.Validator" href="#validator.validators.Validator">Validator</a></code></h4>
<ul class="">
<li><code><a title="validator.validators.Validator.apply" href="#validator.validators.Validator.apply">apply</a></code></li>
<li><code><a title="validator.validators.Validator.get_error" href="#validator.validators.Validator.get_error">get_error</a></code></li>
<li><code><a title="validator.validators.Validator.get_fun_type" href="#validator.validators.Validator.get_fun_type">get_fun_type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>